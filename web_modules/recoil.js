import"./common/_commonjsHelpers-ef01b4ac.js";import{r as N}from"./common/index-aec5dcf5.js";import{r as ge}from"./common/index-e2ad63f4.js";function I(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class we{constructor(e){I(this,"key",void 0),this.key=e}}class Je extends we{}class Xe extends we{}function jt(e){return e instanceof Je||e instanceof Xe}var te={AbstractRecoilValue:we,RecoilState:Je,RecoilValueReadOnly:Xe,isRecoilValue:jt},Gt=te.AbstractRecoilValue,zt=te.RecoilState,Ht=te.RecoilValueReadOnly,Yt=te.isRecoilValue,$=Object.freeze({__proto__:null,AbstractRecoilValue:Gt,RecoilState:zt,RecoilValueReadOnly:Ht,isRecoilValue:Yt});class Qe{}const Kt=new Qe();class Jt extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const z=new Map(),Ze=new Map();function Xt(e){if(z.has(e.key)){const n=`Duplicate atom key "${e.key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`}z.set(e.key,e);const t=e.set==null?new $.RecoilValueReadOnly(e.key):new $.RecoilState(e.key);return Ze.set(e.key,t),t}class et extends Error{}function Qt(e){const t=z.get(e);if(t==null)throw new et(`Missing definition for RecoilValue: "${e}""`);return t}function Zt(e){return z.get(e)}var C={nodes:z,recoilValues:Ze,registerNode:Xt,getNode:Qt,getNodeMaybe:Zt,NodeMissingError:et,DefaultValue:Qe,DEFAULT_VALUE:Kt,RecoilValueNotReady:Jt};function en(e,t){t()}var tn={enqueueExecution:en};function nn(e,t){const n=new Set(e);return n.add(t),n}function on(e,t){const n=new Set(e);return n.delete(t),n}function rn(e,t,n){const o=new Map(e);return o.set(t,n),o}function an(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function sn(e,t){const n=new Map(e);return n.delete(t),n}function ln(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var ne={setByAddingToSet:nn,setByDeletingFromSet:on,mapBySettingInMap:rn,mapByUpdatingInMap:an,mapByDeletingFromMap:sn,mapByDeletingMultipleFromMap:ln};const{mapByDeletingFromMap:cn,mapBySettingInMap:un,setByAddingToSet:dn}=ne,{getNode:ve,getNodeMaybe:hn}=C,fn=Object.freeze(new Set());class pn extends Error{}function mn(e,t,n){return ve(n).get(e,t)}function bn(e,t,n){return ve(n).peek(e,t)}function yn(e,t,n){var o;const r=hn(t);return r==null||((o=r.invalidate)===null||o===void 0)||o.call(r),{...e,atomValues:cn(e.atomValues,t),nonvalidatedAtoms:un(e.nonvalidatedAtoms,t,n),dirtyAtoms:dn(e.dirtyAtoms,t)}}function gn(e,t,n,o){const r=ve(n);if(r.set==null)throw new pn(`Attempt to set read-only RecoilValue: ${n}`);return r.set(e,t,o)}function wn(e,t,n){const o=new Set(),r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const u=(s=a.nodeToNodeSubscriptions.get(i))!==null&&s!==void 0?s:fn;for(const l of u)o.has(l)||r.push(l)}return o}var oe={getNodeLoadable:mn,peekNodeLoadable:bn,setNodeValue:gn,setUnvalidatedAtomValue:yn,getDownstreamNodes:wn};function vn(e,...t){const n=new Set();e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var re=vn;function Sn(e,t){const n=new Map();return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var H=Sn;function Rn(e,t){if(e!=null)return e;throw new Error(t??"Got unexpected null or undefined")}var E=Rn;function Tn(){return{nodeDeps:new Map(),nodeToNodeSubscriptions:new Map()}}function En(e){return{nodeDeps:H(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:H(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Se(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach((a,s)=>{const i=o.get(s);if(i&&n&&i!==n.nodeDeps.get(s))return;o.set(s,new Set(a));const u=i==null?a:re(a,i);if(u.forEach(l=>{r.has(l)||r.set(l,new Set());const b=E(r.get(l));b.add(s)}),i){const l=re(i,a);l.forEach(b=>{if(!r.has(b))return;const y=E(r.get(b));y.delete(s),y.size===0&&r.delete(b)})}})}function _n(e,t,n){var o,r,a,s;const i=t.getState();!(n===i.currentTree.version||n===((o=i.nextTree)===null||o===void 0?void 0:o.version)||n===((r=i.previousTree)===null||r===void 0?void 0:r.version));const u=t.getGraph(n);if(Se(e,u),n===((a=i.previousTree)===null||a===void 0?void 0:a.version)){const b=t.getGraph(i.currentTree.version);Se(e,b,u)}if(n===((s=i.previousTree)===null||s===void 0?void 0:s.version)||n===i.currentTree.version){var l;const b=(l=i.nextTree)===null||l===void 0?void 0:l.version;if(b!==void 0){const y=t.getGraph(b);Se(e,y,u)}}}function An(e,t){e.forEach((n,o)=>{t.has(o)||t.set(o,new Set());const r=E(t.get(o));n.forEach(a=>r.add(a))})}function Vn(e,t,n){n.has(e)||n.set(e,new Set()),E(n.get(e)).add(t)}var B={addToDependencyMap:Vn,cloneGraph:En,graph:Tn,mergeDepsIntoDependencyMap:An,saveDependencyMapToStore:_n};function Nn(e,t,n){return n()}function Mn(e){return e}var A={trace:Nn,wrap:Mn};function In(...e){const t=new Set();for(const n of e)for(const o of n)t.add(o);return t}var ae=In;const{mapByDeletingFromMap:Dn,mapByDeletingMultipleFromMap:Ln}=ne,{getNodeLoadable:tt,setNodeValue:kn,setUnvalidatedAtomValue:Fn}=oe,{saveDependencyMapToStore:nt}=B,{DefaultValue:ot,RecoilValueNotReady:On}=C,{AbstractRecoilValue:Cn,RecoilState:Pn,RecoilValueReadOnly:Un,isRecoilValue:xn}=$;function $n(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();!(n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version));const[s,i]=tt(e,n,t);return nt(s,e,n.version),i}function Re(e,t){const n=H(e,o=>o);return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof ot?n.delete(r):n.set(r,o)}),n}function Bn(e,{key:t},n){if(typeof n=="function"){var o;const r=e.getState(),a=(o=r.nextTree)!==null&&o!==void 0?o:r.currentTree,s=tt(e,a,t)[1];if(s.state==="loading")throw new On(t);if(s.state==="hasError")throw s.contents;return n(s.contents)}else return n}function rt(e,t,n){const{key:o}=t;A.trace("set RecoilValue",o,()=>e.replaceState(A.wrap(r=>{const a=Bn(e,t,n),[s,i]=kn(e,r,o,a),u=new Set(i.keys());return nt(s,e,r.version),{...r,dirtyAtoms:ae(r.dirtyAtoms,u),atomValues:Re(r.atomValues,i),nonvalidatedAtoms:Ln(r.nonvalidatedAtoms,u)}})))}function qn(e,t,n){if(n instanceof ot)return rt(e,t,n);const{key:o}=t;A.trace("set RecoilValue",o,()=>e.replaceState(A.wrap(r=>{const a=new Set([o]);return{...r,dirtyAtoms:ae(r.dirtyAtoms,a),atomValues:Re(r.atomValues,new Map([[o,n]])),nonvalidatedAtoms:Dn(r.nonvalidatedAtoms,o)}})))}function Wn(e,{key:t}){A.trace("mark RecoilValue modified",t,()=>e.replaceState(A.wrap(n=>({...n,dirtyAtoms:ae(n.dirtyAtoms,new Set([t]))}))))}function jn(e,{key:t},n){A.trace("set unvalidated persisted atom",t,()=>e.replaceState(A.wrap(o=>{const r=Fn(o,t,n);return r})))}let Gn=0;function zn(e,{key:t},n){const o=Gn++,r=e.getState();return r.nodeToComponentSubscriptions.has(t)||r.nodeToComponentSubscriptions.set(t,new Map()),E(r.nodeToComponentSubscriptions.get(t)).set(o,["TODO debug name",n]),{release:()=>{const a=e.getState(),s=a.nodeToComponentSubscriptions.get(t);if(s===void 0||!s.has(o))return;s.delete(o),s.size===0&&a.nodeToComponentSubscriptions.delete(t)}}}var Y={RecoilValueReadOnly:Un,AbstractRecoilValue:Cn,RecoilState:Pn,getRecoilValueAsLoadable:$n,setRecoilValue:rt,setRecoilValueLoadable:qn,markRecoilValueModified:Wn,setUnvalidatedRecoilValue:jn,subscribeToRecoilValue:zn,isRecoilValue:xn,applyAtomValueWrites:Re};function*Hn(e){for(const t of e)for(const n of t)yield n}var Yn=Hn;function*Kn(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var at=Kn;const Te=new Map();function Ee(e){var t;return(t=Te.get(e))!==null&&t!==void 0?t:!1}Ee.setPass=e=>{Te.set(e,!0)},Ee.setFail=e=>{Te.set(e,!1)};var se=Ee;function Jn(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Xn=Jn;const{graph:Qn}=B;let Zn=0;const st=()=>Zn++;function it(){const e=st();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set(),atomValues:new Map(),nonvalidatedAtoms:new Map()}}function eo(){const e=it();return{currentTree:e,nextTree:null,previousTree:null,knownAtoms:new Set(),knownSelectors:new Set(),transactionSubscriptions:new Map(),nodeTransactionSubscriptions:new Map(),nodeToComponentSubscriptions:new Map(),queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set(),graphsByVersion:new Map().set(e.version,Qn()),versionsUsedByComponent:new Map()}}var lt={makeEmptyTreeState:it,makeEmptyStoreState:eo,getNextTreeStateVersion:st};const{getDownstreamNodes:to,peekNodeLoadable:no}=oe,{graph:oo}=B,{DEFAULT_VALUE:ro,recoilValues:_e}=C,{getRecoilValueAsLoadable:ao,setRecoilValue:ct}=Y,{getNextTreeStateVersion:so,makeEmptyStoreState:io}=lt;function K(e){return Xn(e,t=>E(_e.get(t)))}class ie{constructor(e){I(this,"_store",void 0),I(this,"getLoadable",t=>ao(this._store,t)),I(this,"getPromise",t=>se("recoil_async_selector_refactor")?this.getLoadable(t).toPromise().then(({value:n})=>n):this.getLoadable(t).toPromise()),I(this,"getNodes_UNSTABLE",t=>{if((t==null?void 0:t.isModified)===!0){if((t==null?void 0:t.isInitialized)===!1)return[];const r=this._store.getState().currentTree;return K(r.dirtyAtoms)}const n=this._store.getState().knownAtoms,o=this._store.getState().knownSelectors;return(t==null?void 0:t.isInitialized)==null?_e.values():t.isInitialized===!0?K(Yn([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):at(_e.values(),({key:r})=>!n.has(r)&&!o.has(r))}),I(this,"getDeps_UNSTABLE",t=>{this.getLoadable(t);const n=this._store.getGraph(this._store.getState().currentTree.version).nodeDeps.get(t.key);return K(n??[])}),I(this,"getSubscribers_UNSTABLE",({key:t})=>{const n=this._store.getState().currentTree,o=at(to(this._store,n,new Set([t])),r=>r!==t);return{nodes:K(o)}}),I(this,"getInfo_UNSTABLE",t=>{var n;const{key:o}=t,r=this._store.getState().currentTree,a=this._store.getGraph(r.version);return{loadable:no(this._store,r,o),isActive:this._store.getState().knownAtoms.has(o)||this._store.getState().knownSelectors.has(o),isSet:r.atomValues.has(o),isModified:r.dirtyAtoms.has(o),type:this._store.getState().knownAtoms.has(o)?"atom":this._store.getState().knownSelectors.has(o)?"selector":void 0,deps:K((n=a.nodeDeps.get(o))!==null&&n!==void 0?n:[]),subscribers:this.getSubscribers_UNSTABLE(t)}}),I(this,"map",t=>{const n=new Ve(this);return t(n),Ae(n.getStore_INTERNAL())}),I(this,"asyncMap",async t=>{const n=new Ve(this);return await t(n),Ae(n.getStore_INTERNAL())}),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return E(n.get(t));const o=oo();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}}}getStore_INTERNAL(){return this._store}getID(){return this.getID_INTERNAL()}getID_INTERNAL(){return this._store.getState().currentTree.stateID}}function ut(e,t,n=!1){const o=e.getState(),r=n?so():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:new Map(t.atomValues),nonvalidatedAtoms:new Map(t.nonvalidatedAtoms)}:t,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map(),nodeTransactionSubscriptions:new Map(),nodeToComponentSubscriptions:new Map(),queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set(),graphsByVersion:new Map().set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map()}}function lo(){return new ie(io())}function Ae(e,t="current"){const n=e.getState(),o=t==="current"?n.currentTree:E(n.previousTree);return new ie(ut(e,o))}class Ve extends ie{constructor(e){super(ut(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0));I(this,"set",(t,n)=>{const o=this.getStore_INTERNAL();ct(o,t,n)}),I(this,"reset",t=>ct(this.getStore_INTERNAL(),t,ro))}}var le={Snapshot:ie,MutableSnapshot:Ve,freshSnapshot:lo,cloneSnapshot:Ae},co=le.Snapshot,uo=le.MutableSnapshot,ho=le.freshSnapshot,fo=le.cloneSnapshot,dt=Object.freeze({__proto__:null,Snapshot:co,MutableSnapshot:uo,freshSnapshot:ho,cloneSnapshot:fo});const{useContext:ht,useEffect:po,useMemo:mo,useRef:Ne,useState:bo}=N,{getDownstreamNodes:yo,setNodeValue:go,setUnvalidatedAtomValue:wo}=oe,{graph:vo,saveDependencyMapToStore:So}=B,{cloneGraph:Ro}=B,{applyAtomValueWrites:To}=Y,{freshSnapshot:Eo}=dt,{getNextTreeStateVersion:_o,makeEmptyStoreState:ft}=lt,{mapByDeletingMultipleFromMap:Ao}=ne;function J(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Vo=Object.freeze({getState:J,replaceState:J,getGraph:J,subscribeToTransactions:J,addTransactionMetadata:J});let Me=!1;function pt(e){if(Me)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");if(e.nextTree===null){const t=e.currentTree.version,n=_o();e.nextTree={...e.currentTree,version:n,stateID:n,dirtyAtoms:new Set(),transactionMetadata:{}},e.graphsByVersion.set(n,Ro(E(e.graphsByVersion.get(t))))}}const mt=N.createContext({current:Vo}),bt=()=>ht(mt),yt=N.createContext(null),No=()=>ht(yt);function gt(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[s,i]of t.nodeTransactionSubscriptions)if(o.has(s))for(const[u,l]of i)l(e);for(const[s,i]of t.transactionSubscriptions)i(e);const r=yo(e,n,o);for(const s of r){const i=t.nodeToComponentSubscriptions.get(s);if(i)for(const[u,[l,b]]of i)b(n)}let a="[available in dev build]";t.suspendedComponentResolvers.forEach(s=>A.trace("value became available, waking components",a,s))}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Mo(e){const t=bt(),[n,o]=bo([]);return e.setNotifyBatcherOfChange(()=>o({})),po(()=>{tn.enqueueExecution("Batcher",()=>{const r=t.current.getState(),{nextTree:a}=r;if(a===null)return;r.previousTree=r.currentTree,r.currentTree=a,r.nextTree=null,gt(t.current);const s=E(r.previousTree).version;r.graphsByVersion.delete(s),r.previousTree=null})}),null}function Io(e,t){const n=ft();return t({set:(o,r)=>{const a=n.currentTree,[s,i]=go(e,a,o.key,r),u=new Set(i.keys());So(s,e,a.version);const l=Ao(a.nonvalidatedAtoms,u);n.currentTree={...a,dirtyAtoms:ae(a.dirtyAtoms,u),atomValues:To(a.atomValues,i),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=wo(n.currentTree,a,r)})}}),n}function Do(e){const t=Eo().map(e);return t.getStore_INTERNAL().getState()}let wt=0;function Lo({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let a;const s=c=>{const d=a.current.graphsByVersion;if(d.has(c))return E(d.get(c));const f=vo();return d.set(c,f),f},i=(c,d)=>{if(d==null){const{transactionSubscriptions:f}=g.current.getState(),S=wt++;return f.set(S,c),{release:()=>{f.delete(S)}}}else{const{nodeTransactionSubscriptions:f}=g.current.getState();f.has(d)||f.set(d,new Map());const S=wt++;return E(f.get(d)).set(S,c),{release:()=>{const T=f.get(d);T&&(T.delete(S),T.size===0&&f.delete(d))}}}},u=c=>{pt(g.current.getState());for(const d of Object.keys(c))E(g.current.getState().nextTree).transactionMetadata[d]=c[d]},l=c=>{const d=g.current.getState();pt(d);const f=E(d.nextTree);let S;try{Me=!0,S=c(f)}finally{Me=!1}if(S===f)return;d.nextTree=S,E(b.current)()},b=Ne(null);function y(c){b.current=c}const p=(r=N.createMutableSource)!==null&&r!==void 0?r:N.unstable_createMutableSource,m=n??{getState:()=>a.current,replaceState:l,getGraph:s,subscribeToTransactions:i,addTransactionMetadata:u},g=Ne(m);a=Ne(e!=null?Io(m,e):t!=null?Do(t):ft());const h=mo(()=>p?p(a,()=>a.current.currentTree.version):null,[p,a]);return N.createElement(mt.Provider,{value:g},N.createElement(yt.Provider,{value:h},N.createElement(Mo,{setNotifyBatcherOfChange:y}),o))}var Ie={useStoreRef:bt,useRecoilMutableSource:No,RecoilRoot:Lo,sendEndOfBatchNotifications_FOR_TESTING:gt};function ko(e,t){const n=new Map();for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var Fo=ko;function Oo(e,t){const n=new Set();for(const o of e)t(o)&&n.add(o);return n}var Co=Oo;function Po(e,t){if(!e)throw new Error(t)}var Uo=Po,xo=Uo;function $o(...e){const t=new Map();for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Bo=$o,De;const{useCallback:k,useEffect:ce,useMemo:qo,useRef:Le,useState:ke}=N,{DEFAULT_VALUE:ue,getNode:vt,nodes:Wo}=C,{useRecoilMutableSource:jo,useStoreRef:D}=Ie,{AbstractRecoilValue:Fe,getRecoilValueAsLoadable:Oe,setRecoilValue:q,setRecoilValueLoadable:Go,setUnvalidatedRecoilValue:zo,subscribeToRecoilValue:Ce}=Y,{Snapshot:Ma,cloneSnapshot:X}=dt,{setByAddingToSet:Ho}=ne;function St(e,t,n){if(e.state==="hasValue")return e.contents;if(e.state==="loading"){const o=new Promise(r=>{n.current.getState().suspendedComponentResolvers.add(r)});throw o}else throw e.state==="hasError"?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Yo(){const e=D(),[t,n]=ke([]),o=Le(new Set());o.current=new Set();const r=Le(new Set()),a=Le(new Map()),s=k(i=>{const u=a.current.get(i);u&&(u.release(e.current),a.current.delete(i))},[e,a]);return ce(()=>{const i=e.current;function u(l,b){if(!a.current.has(b))return;n([])}re(o.current,r.current).forEach(l=>{if(a.current.has(l))return;const b=Ce(i,new Fe(l),y=>{A.trace("RecoilValue subscription fired",l,()=>{u(y,l)})});a.current.set(l,b),A.trace("initial update on subscribing",l,()=>{const y=i.getState();y.nextTree?i.getState().queuedComponentCallbacks_DEPRECATED.push(A.wrap(()=>{u(i.getState(),l)})):u(i.getState(),l)})}),re(r.current,o.current).forEach(l=>{s(l)}),r.current=o.current}),ce(()=>{const i=a.current;return()=>i.forEach((u,l)=>s(l))},[s]),qo(()=>{function i(m){return g=>{q(e.current,m,g)}}function u(m){return()=>q(e.current,m,ue)}function l(m){return o.current.has(m.key)||(o.current=Ho(o.current,m.key)),Oe(e.current,m)}function b(m){const g=l(m);return St(g,m,e)}function y(m){return[b(m),i(m)]}function p(m){return[l(m),i(m)]}return{getRecoilValue:b,getRecoilValueLoadable:l,getRecoilState:y,getRecoilStateLoadable:p,getSetRecoilState:i,getResetRecoilState:u}},[o,e])}const Ko={current:0};function Jo(e){const t=D(),n=k(()=>Oe(t.current,e,t.current.getState().currentTree),[t,e]),o=k((r,a)=>{const s=t.current,i=Ce(s,e,()=>{A.trace("RecoilValue subscription fired",e.key,()=>{a()})});return()=>i.release(s)},[e,t]);return Rt(jo(),n,o)}function Xo(e){const t=D(),[n,o]=ke([]);return ce(()=>{const r=t.current,a=Ce(r,e,s=>{A.trace("RecoilValue subscription fired",e.key,()=>{o([])})});return A.trace("initial update on subscribing",e.key,()=>{const s=r.getState();s.nextTree?r.getState().queuedComponentCallbacks_DEPRECATED.push(A.wrap(()=>{o([])})):o([])}),()=>a.release(r)},[e,t]),Oe(t.current,e)}const Rt=(De=N.useMutableSource)!==null&&De!==void 0?De:N.unstable_useMutableSource;function Pe(e){return Rt&&!(typeof window!="undefined"&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)?Jo(e):Xo(e)}function Tt(e){const t=D(),n=Pe(e);return St(n,e,t)}function Ue(e){const t=D();return k(n=>{q(t.current,e,n)},[t,e])}function Qo(e){const t=D();return k(()=>{q(t.current,e,ue)},[t,e])}function Zo(e){return[Tt(e),Ue(e)]}function er(e){return[Pe(e),Ue(e)]}function de(e){const t=D();ce(()=>{const n=t.current.subscribeToTransactions(e);return n.release},[e,t])}function Et(e){const t=e.atomValues,n=H(Fo(t,(o,r)=>{const a=vt(r),s=a.persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Bo(e.nonvalidatedAtoms,n)}function tr(e){de(k(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Et(o),a=Et(n),s=H(Wo,u=>{var l,b,y,p;return{persistence_UNSTABLE:{type:(l=(b=u.persistence_UNSTABLE)===null||b===void 0?void 0:b.type)!==null&&l!==void 0?l:"none",backButton:(y=(p=u.persistence_UNSTABLE)===null||p===void 0?void 0:p.backButton)!==null&&y!==void 0?y:!1}}}),i=Co(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})},[e]))}function nr(e){de(k(t=>{e({snapshot:X(t,"current"),previousSnapshot:X(t,"previous")})},[e]))}function or(){const e=D(),[t,n]=ke(()=>X(e.current));return de(k(o=>n(X(o)),[])),t}function _t(){const e=D();return k(t=>{var n;const o=e.current.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;ge.unstable_batchedUpdates(()=>{const s=new Set();for(const l of[r.atomValues.keys(),a.atomValues.keys()])for(const b of l){var i,u;((i=r.atomValues.get(b))===null||i===void 0?void 0:i.contents)!==((u=a.atomValues.get(b))===null||u===void 0?void 0:u.contents)&&vt(b).shouldRestoreFromSnapshots&&s.add(b)}s.forEach(l=>{Go(e.current,new Fe(l),a.atomValues.has(l)?E(a.atomValues.get(l)):ue)}),e.current.replaceState(l=>({...l,stateID:t.getID_INTERNAL()}))})},[e])}function rr(){const e=D();return(t,n={})=>{ge.unstable_batchedUpdates(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>zo(e.current,new Fe(r),o))})}}class At{}const ar=new At();function sr(e,t){const n=D(),o=_t();return k((...r)=>{const a=X(n.current);function s(l,b){q(n.current,l,b)}function i(l){q(n.current,l,ue)}let u=ar;return ge.unstable_batchedUpdates(()=>{u=e({set:s,reset:i,snapshot:a,gotoSnapshot:o})(...r)}),u instanceof At&&xo(!1),u},t!=null?[...t,n]:void 0)}var ir={recoilComponentGetRecoilValueCount_FOR_TESTING:Ko,useGotoRecoilSnapshot:_t,useRecoilCallback:sr,useRecoilInterface:Yo,useRecoilSnapshot:or,useRecoilState:Zo,useRecoilStateLoadable:er,useRecoilTransactionObserver:nr,useRecoilValue:Tt,useRecoilValueLoadable:Pe,useResetRecoilState:Qo,useSetRecoilState:Ue,useSetUnvalidatedAtomValues:rr,useTransactionObservation_DEPRECATED:tr,useTransactionSubscription_DEPRECATED:de};const{useMemo:lr}=N,{RecoilRoot:cr,useStoreRef:ur}=Ie;function dr(){const e=ur().current;return lr(()=>{function t({children:n}){return N.createElement(cr,{store_INTERNAL:e},n)}return t},[e])}var hr=dr;function fr(e){return!!e&&typeof e.then=="function"}var V=fr;const xe={getValue(){if(this.state!=="hasValue")throw this.contents;return this.contents},toPromise(){return this.state==="hasValue"?Promise.resolve(this.contents):this.state==="hasError"?Promise.reject(this.contents):this.contents},valueMaybe(){return this.state==="hasValue"?this.contents:void 0},valueOrThrow(){if(this.state!=="hasValue")throw new Error(`Loadable expected value, but in "${this.state}" state`);return this.contents},errorMaybe(){return this.state==="hasError"?this.contents:void 0},errorOrThrow(){if(this.state!=="hasError")throw new Error(`Loadable expected error, but in "${this.state}" state`);return this.contents},promiseMaybe(){return this.state==="loading"?this.contents:void 0},promiseOrThrow(){if(this.state!=="loading")throw new Error(`Loadable expected promise, but in "${this.state}" state`);return this.contents},map(e){if(this.state==="hasError")return this;if(this.state==="hasValue")try{const t=e(this.contents);return V(t)?W(t):$e(t)}catch(t){return V(t)?W(t.next(()=>e(this.contents))):Be(t)}if(this.state==="loading")return W(this.contents.then(e).catch(t=>{if(V(t))return t.then(()=>e(this.contents));throw t}));throw new Error("Invalid Loadable state")}};function $e(e){return Object.freeze({state:"hasValue",contents:e,...xe})}function Be(e){return Object.freeze({state:"hasError",contents:e,...xe})}function W(e){return Object.freeze({state:"loading",contents:e,...xe})}function pr(){return W(new Promise(()=>{}))}function mr(e){return e.every(t=>t.state==="hasValue")?$e(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Be(E(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):W(se("recoil_async_selector_refactor")?Promise.all(e.map(t=>t.contents)).then(t=>({value:t})):Promise.all(e.map(t=>t.contents)))}var qe={loadableWithValue:$e,loadableWithError:Be,loadableWithPromise:W,loadableLoading:pr,loadableAll:mr};const he=Symbol("ArrayKeyedMap"),br=new Map();class Vt{constructor(e){if(this._base=new Map(),e instanceof Vt)for(const[t,n]of e.entries())this.set(t,n);else if(e)for(const[t,n]of e)this.set(t,n);return this}get(e){const t=Array.isArray(e)?e:[e];let n=this._base;return t.forEach(o=>{var r;n=(r=n.get(o))!==null&&r!==void 0?r:br}),n===void 0?void 0:n.get(he)}set(e,t){const n=Array.isArray(e)?e:[e];let o=this._base,r=o;return n.forEach(a=>{r=o.get(a),r||(r=new Map(),o.set(a,r)),o=r}),r.set(he,t),this}delete(e){const t=Array.isArray(e)?e:[e];let n=this._base,o=n;return t.forEach(r=>{o=n.get(r),o||(o=new Map(),n.set(r,o)),n=o}),o.delete(he),this}entries(){const e=[];function t(n,o){n.forEach((r,a)=>{a===he?e.push([o,r]):t(r,o.concat(a))})}return t(this._base,[]),e.values()}toBuiltInMap(){return new Map(this.entries())}}var yr=Vt;function gr(){return new yr()}var We=gr;function wr(e){return()=>null}var vr={startPerfBlock:wr};const{loadableWithError:Nt,loadableWithPromise:Mt,loadableWithValue:It}=qe,{getNodeLoadable:je,peekNodeLoadable:Sr,setNodeValue:Rr}=oe,{addToDependencyMap:Tr,mergeDepsIntoDependencyMap:Q,saveDependencyMapToStore:Ge}=B,{DEFAULT_VALUE:Er,RecoilValueNotReady:_r,registerNode:Dt}=C,{AbstractRecoilValue:Lt}=$,{getRecoilValueAsLoadable:Ar,isRecoilValue:Vr,setRecoilValueLoadable:Nr}=Y,{startPerfBlock:Mr}=vr,kt=Object.freeze(new Set());function ze(e){const t=[];for(const n of Array.from(e.keys()).sort()){const o=E(e.get(n));t.push(n),t.push(o.state),t.push(o.contents)}return t}const fe=new Map();function Ir(e){const{key:t,get:n,cacheImplementation_UNSTABLE:o}=e,r=e.set!=null?e.set:void 0;let a=o??We();function s(h){h.getState().knownSelectors.add(t)}function i(h,c){if(c.state==="loading"){let d=fe.get(c);d===void 0&&fe.set(c,d=new Set()),d.add(h)}}function u(h,c){const d=fe.get(h);if(d!==void 0){for(const f of d)Nr(f,new Lt(t),c);fe.delete(h)}}function l(h,c){c.state!=="loading"||c.contents.then(d=>{const f=It(d);return a=a.set(h,f),u(c,f),d}).catch(d=>{if(V(d))return d;const f=Nt(d);return a=a.set(h,f),u(c,f),d}),a=a.set(h,c)}function b(h,c){var d;const f=new Map(),S=(d=h.getGraph(c.version).nodeDeps.get(t))!==null&&d!==void 0?d:kt,T=new Map(Array.from(S).sort().map(O=>{const[G,x]=je(h,c,O);return Q(G,f),Ge(f,h,c.version),[O,x]})),R=ze(T),v=a.get(R);if(v!=null)return i(h,v),[f,v];const[w,_,M]=y(h,c);Q(w,f),Ge(f,h,c.version);const F=ze(M);return i(h,_),l(F,_),[f,_]}function y(h,c){const d=Mr(t),f=new Map(),S=new Map();function T({key:R}){Tr(t,R,S);const[v,w]=je(h,c,R);if(f.set(R,w),Q(v,S),Ge(S,h,c.version),w.state==="hasValue")return w.contents;throw w.contents}try{const R=n({get:T}),v=Vr(R)?T(R):R;let w;return V(v)?w=Mt(v.finally(d)):(d(),w=It(v)),[S,w,f]}catch(R){const v=R.then!==void 0;let w;return v?w=Mt(R.then(()=>{const _=Ar(h,new Lt(t));if(_.state==="hasError")throw _.contents;return _.contents}).finally(d)):(d(),w=Nt(R)),[S,w,f]}}function p(h,c){var d;const f=(d=h.getGraph(c.version).nodeDeps.get(t))!==null&&d!==void 0?d:kt,S=new Map(Array.from(f).sort().map(v=>[v,Sr(h,c,v)])),T=new Map();for(const[v,w]of S.entries()){if(w==null)return;T.set(v,w)}const R=ze(T);return a.get(R)}function m(h,c){return s(h),b(h,c)}if(r!=null){function g(h,c,d){s(h);const f=new Map(),S=new Map();function T({key:w}){const[_,M]=je(h,c,w);if(Q(_,f),M.state==="hasValue")return M.contents;throw M.state==="loading"?new _r(w):M.contents}function R(w,_){const M=typeof _=="function"?_(T(w)):_,[F,O]=Rr(h,c,w.key,M);Q(F,f),O.forEach((G,x)=>S.set(x,G))}function v(w){R(w,Er)}return r({set:R,get:T,reset:v},d),[f,S]}return Dt({key:t,peek:p,get:m,set:g,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}else return Dt({key:t,peek:p,get:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}var Dr=Ir,pe=Dr;const{loadableWithError:Ft,loadableWithPromise:Ot,loadableWithValue:Z}=qe,{DEFAULT_VALUE:P,DefaultValue:j,registerNode:Lr}=C,{isRecoilValue:kr}=$,{markRecoilValueModified:Fr,setRecoilValue:Ct,setRecoilValueLoadable:Or}=Y;function Cr(e){const{key:t,persistence_UNSTABLE:n}=e;let o=V(e.default)?Ot(e.default.then(p=>(o=Z(p),p)).catch(p=>{throw o=Ft(p),p})):Z(e.default),r;function a(p,m){const g=m.then(h=>{var c,d;const f=(c=p.getState().nextTree)!==null&&c!==void 0?c:p.getState().currentTree;return((d=f.atomValues.get(t))===null||d===void 0?void 0:d.contents)===g&&Ct(p,y,h),h}).catch(h=>{var c,d;const f=(c=p.getState().nextTree)!==null&&c!==void 0?c:p.getState().currentTree;throw((d=f.atomValues.get(t))===null||d===void 0?void 0:d.contents)===g&&Or(p,y,Ft(h)),h});return g}function s(p,m,g){if(p.getState().knownAtoms.has(t))return;if(p.getState().knownAtoms.add(t),o.state==="loading"){function h(){var T;const R=(T=p.getState().nextTree)!==null&&T!==void 0?T:p.getState().currentTree;R.atomValues.has(t)||Fr(p,y)}o.contents.then(h).catch(h)}let c=P;if(e.effects_UNSTABLE!=null){let T=!0;function d(v){if(T){const w=c instanceof j||V(c)?o.state==="hasValue"?o.contents:P:c;c=typeof v=="function"?v(w):v}else{if(V(v))throw new Error("Setting atoms to async values is not implemented.");Ct(p,y,v)}}const R=()=>d(P);function f(v){p.subscribeToTransactions(w=>{let{currentTree:_,previousTree:M}=w.getState();M||(M=_);const F=_.atomValues.get(t);if(F==null||F.state==="hasValue"){var O;const G=F!=null?F.contents:P,x=(O=M.atomValues.get(t))!==null&&O!==void 0?O:o,Wt=x.state==="hasValue"?x.contents:P;v(G,Wt)}},t)}for(const v of(S=e.effects_UNSTABLE)!==null&&S!==void 0?S:[]){var S;v({node:y,trigger:g,setSelf:d,resetSelf:R,onSet:f})}T=!1}c instanceof j||m.atomValues.set(t,V(c)?Ot(a(p,c)):Z(c))}function i(p,m){var g,h,c;return(g=(h=m.atomValues.get(t))!==null&&h!==void 0?h:(c=r)===null||c===void 0?void 0:c[1])!==null&&g!==void 0?g:o}function u(p,m){if(s(p,m,"get"),m.atomValues.has(t))return[new Map(),E(m.atomValues.get(t))];if(m.nonvalidatedAtoms.has(t)){if(r!=null)return r;if(n==null)return[new Map(),o];const g=m.nonvalidatedAtoms.get(t),h=n.validator(g,P),c=h instanceof j?o:Z(h);return r=[new Map(),c],r}else return[new Map(),o]}function l(){r=void 0}function b(p,m,g){if(s(p,m,"set"),m.atomValues.has(t)){const h=E(m.atomValues.get(t));if(h.state==="hasValue"&&g===h.contents)return[new Map(),new Map()]}else if(!m.nonvalidatedAtoms.has(t)&&g instanceof j)return[new Map(),new Map()];return r=void 0,[new Map(),new Map().set(t,Z(g))]}const y=Lr({key:t,peek:i,get:u,set:b,invalidate:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0});return y}function Pt(e){const{default:t,...n}=e;return kr(t)?Pr({...n,default:t}):Cr({...n,default:t})}function Pr(e){const t=Pt({...e,default:P,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:n=>n instanceof j?n:E(e.persistence_UNSTABLE).validator(n,P)},effects_UNSTABLE:e.effects_UNSTABLE});return pe({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof j?e.default:o},set:({set:n},o)=>n(t,o),dangerouslyAllowMutability:e.dangerouslyAllowMutability})}var He=Pt;function L(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(V(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>L(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return L(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:L(a,t)]=s;return L(r,t,n)}return e instanceof Set?L(Array.from(e).sort((r,a)=>L(r,t).localeCompare(L(a,t))),t,n):e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?L(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${L(r,t)}:${L(e[r],t,r)}`).join(",")}}`}function Ur(e,t={allowFunctions:!1}){return L(e,t)}var me=Ur;function xr(){const e=new Map(),t={get:n=>e.get(me(n)),set:(n,o)=>(e.set(me(n),o),t),map:e};return t}var Ut=xr;let $r=0;function Br(e){var t,n;let o=(t=(n=e.cacheImplementationForParams_UNSTABLE)===null||n===void 0?void 0:n.call(e))!==null&&t!==void 0?t:Ut();return r=>{var a,s;const i=o.get(r);if(i!=null)return i;const u=`${e.key}__selectorFamily/${(a=me(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${$r++}`,l=p=>e.get(r)(p),b=(s=e.cacheImplementation_UNSTABLE)===null||s===void 0?void 0:s.call(e);let y;if(e.set!=null){const p=e.set,m=(g,h)=>p(r)(g,h);y=pe({key:u,get:l,set:m,cacheImplementation_UNSTABLE:b,dangerouslyAllowMutability:e.dangerouslyAllowMutability})}else y=pe({key:u,get:l,cacheImplementation_UNSTABLE:b,dangerouslyAllowMutability:e.dangerouslyAllowMutability});return o=o.set(r,y),y}}var U=Br;const{DEFAULT_VALUE:qr,DefaultValue:Wr}=C;function jr(e){let t=Ut();const n={key:e.key,default:qr,persistence_UNSTABLE:e.persistence_UNSTABLE};let o;o=He(n);const r=U({key:`${e.key}__atomFamily/Default`,get:a=>({get:s})=>{const i=s(typeof o=="function"?o(a):o);return i instanceof Wr?typeof e.default=="function"?e.default(a):e.default:i},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return a=>{var s;const i=t.get(a);if(i!=null)return i;const u=He({...e,key:`${e.key}__${(s=me(a))!==null&&s!==void 0?s:"void"}`,default:r(a),effects_UNSTABLE:typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(a):e.effects_UNSTABLE});return t=t.set(a,u),u}}var Gr=jr;const zr=U({key:"__constant",get:e=>()=>e,cacheImplementationForParams_UNSTABLE:We});function Hr(e){return zr(e)}var Yr=Hr;const Kr=U({key:"__error",get:e=>()=>{throw new Error(e)},cacheImplementationForParams_UNSTABLE:We});function Jr(e){return Kr(e)}var Xr=Jr;function Qr(e){return e}var Zr=Qr;const{loadableWithError:xt,loadableWithPromise:$t,loadableWithValue:Bt}=qe;function Ye(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function ee(e){return e!=null&&!V(e)}function Ke(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function qt(e){return e.hasOwnProperty("value")?e.value:e}function be(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function ye(e,t,n){const o=n.map((r,a)=>r==null?Bt(t[a]):V(r)?$t(r):xt(r));return be(e,o)}const ea=U({key:"__waitForNone",get:e=>({get:t})=>{const n=Ke(e),[o,r]=Ye(t,n);return ye(e,o,r)}}),ta=U({key:"__waitForAny",get:e=>({get:t})=>{const n=Ke(e),[o,r]=Ye(t,n);if(r.some(a=>a==null))return ye(e,o,r);if(r.every(ee))throw r.find(ee);if(se("recoil_async_selector_refactor"))return new Promise((a,s)=>{for(const[i,u]of r.entries())V(u)&&u.then(l=>{o[i]=qt(l),r[i]=null,a(ye(e,o,r))}).catch(l=>{r[i]=l,r.every(ee)&&s(r[0])})});throw new Promise((a,s)=>{for(const[i,u]of r.entries())V(u)&&u.then(l=>{o[i]=l,r[i]=null,a(ye(e,o,r))}).catch(l=>{r[i]=l,r.every(ee)&&s(r[0])})})}}),na=U({key:"__waitForAll",get:e=>({get:t})=>{const n=Ke(e),[o,r]=Ye(t,n);if(r.every(s=>s==null))return be(e,o);const a=r.find(ee);if(a!=null)throw a;if(se("recoil_async_selector_refactor"))return Promise.all(r).then(s=>be(e,s.map(qt)));throw Promise.all(r).then(s=>be(e,s))}}),oa=U({key:"__noWait",get:e=>({get:t})=>{try{return Bt(t(e))}catch(n){return V(n)?$t(n):xt(n)}}});var ra={waitForNone:ea,waitForAny:ta,waitForAll:na,noWait:oa};const{DefaultValue:aa}=C,{RecoilRoot:sa}=Ie,{isRecoilValue:ia}=$,{useGotoRecoilSnapshot:la,useRecoilCallback:ca,useRecoilSnapshot:ua,useRecoilState:da,useRecoilStateLoadable:ha,useRecoilTransactionObserver:fa,useRecoilValue:pa,useRecoilValueLoadable:ma,useResetRecoilState:ba,useSetRecoilState:ya,useSetUnvalidatedAtomValues:ga,useTransactionObservation_DEPRECATED:wa}=ir,{noWait:va,waitForAll:Sa,waitForAny:Ra,waitForNone:Ta}=ra;var Ea={DefaultValue:aa,RecoilRoot:sa,useRecoilBridgeAcrossReactRoots_UNSTABLE:hr,atom:He,selector:pe,atomFamily:Gr,selectorFamily:U,constSelector:Yr,errorSelector:Xr,readOnlySelector:Zr,useRecoilValue:pa,useRecoilValueLoadable:ma,useRecoilState:da,useRecoilStateLoadable:ha,useSetRecoilState:ya,useResetRecoilState:ba,useRecoilCallback:ca,useGotoRecoilSnapshot:la,useRecoilSnapshot:ua,useRecoilTransactionObserver_UNSTABLE:fa,useTransactionObservation_UNSTABLE:wa,useSetUnvalidatedAtomValues_UNSTABLE:ga,noWait:va,waitForNone:Ta,waitForAny:Ra,waitForAll:Sa,isRecoilValue:ia};export default Ea;
